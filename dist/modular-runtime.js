/**
 * Universal Modular Runtime (Bundled)
 * This file is auto-generated by scripts/bundle-modules.js
 * Do not edit directly - edit src/templates/UniversalModularRuntime.js instead
 */

(function() {


/**
 * Positioning Modules
 * Calculate the x, y position of elements
 * Signature: (i, j, cellSize, p5, context)
 */

/**
 * Grid-based positioning (standard grid)
 */
function gridPosition(i, j, cellSize) {
  const x = i * cellSize + cellSize / 2;
  const y = j * cellSize + cellSize / 2;
  return { x, y };
}

/**
 * Offset grid positioning (staggered)
 */
function offsetGridPosition(i, j, cellSize) {
  const offset = j % 2 === 0 ? 0 : cellSize / 2;
  const x = i * cellSize + cellSize / 2 + offset;
  const y = j * cellSize + cellSize / 2;
  return { x, y };
}

/**
 * Circular/spiral positioning
 * Adapted to work with generic signature
 */
function spiralPosition(i, j, cellSize, p5, context) {
  // Use 'i' as linear index if coming from densityTraversal, or i/j from grid
  // If grid, we can flatten it: i + j * gridSize
  let index = i;
  let total = context.config.density || 100;
  
  if (context.gridSize && j !== undefined) {
      index = i + j * context.gridSize;
      total = context.gridSize * context.gridSize;
  }
  
  const centerX = p5.width / 2;
  const centerY = p5.height / 2;
  const maxRadius = Math.min(p5.width, p5.height) * 0.45;
  
  // 3 full rotations by default
  const rotations = 3;
  const angle = (index / total) * Math.PI * 2 * rotations;
  const r = (index / total) * maxRadius;
  
  const x = centerX + Math.cos(angle) * r;
  const y = centerY + Math.sin(angle) * r;
  return { x, y };
}

/**
 * Random positioning within bounds
 */
function randomPosition(i, j, cellSize, p5, context) {
   // Ignores i, j, but we might use them to seed if needed
   // But p5.random() is usually fine if seed was set in setup
   return {
    x: p5.random(p5.width),
    y: p5.random(p5.height),
  };
}

/**
 * Flow field positioning (linear grid)
 */
function flowGridPosition(i, j, cellSize, p5, context) {
  const cols = 10; 
  // We ignore cellSize passed from context if we want fixed columns, 
  // or we could use it. FlowField uses specific layout.
  
  const cellW = p5.width / cols;
  // Estimate rows based on total count
  const count = context.config.density || 80;
  const rows = Math.ceil(count / cols);
  const cellH = p5.height / rows;
  
  const x = (i % cols) * cellW + cellW * 0.1;
  const y = Math.floor(i / cols) * cellH + cellH * 0.5;
  return { x, y };
}




/**
 * Sizing Modules
 * Calculate the size of elements
 */

/**
 * Noise-based sizing (organic, varying sizes)
 * Matches gridPatternRuntime: cellSize * 0.6 * noiseVal
 */
function noiseSize(p5, i, j, t, cell, noiseScale = 0.1) {
  const n = p5.noise(i * noiseScale, j * noiseScale, t * 0.3);
  return cell * 0.6 * n; // Removed (0.5 + n) to match runtime
}

/**
 * Constant sizing (uniform)
 */
function constantSize(p5, i, j, t, cell, baseScale = 0.8) {
  return cell * baseScale;
}

/**
 * Distance-based sizing (smaller at edges)
 */
function distanceSize(p5, i, j, maxI, maxJ, cell, centerScale = 1.0) {
  const centerX = maxI / 2;
  const centerY = maxJ / 2;
  const dist = Math.sqrt((i - centerX) ** 2 + (j - centerY) ** 2);
  const maxDist = Math.sqrt(centerX ** 2 + centerY ** 2);
  const scale = 1 - (dist / maxDist) * 0.5;
  return cell * 0.6 * scale * centerScale;
}

/**
 * Time-based pulsing size
 */
function pulseSize(p5, i, j, t, cell, pulseSpeed = 1.0) {
  const pulse = (Math.sin(t * pulseSpeed) + 1) / 2; // 0 to 1
  return cell * 0.5 + cell * 0.3 * pulse;
}

/**
 * Random sizing per element
 */
function randomSize(
  p5,
  i,
  j,
  cell,
  minScale = 0.3,
  maxScale = 1.0,
  seed = null
) {
  if (seed) p5.randomSeed(seed + i * 1000 + j);
  const scale = p5.random(minScale, maxScale);
  return cell * 0.6 * scale;
}




/**
 * Coloring Modules
 * Calculate the color of elements
 */

/**
 * Time-based color cycling (HSB)
 * Matches gridPatternRuntime exactly
 */
function timeBasedColor(p5, i, j, t, n, palette) {
  // Exact match: const colorIndex = (i + j) % 4;
  const colorIndex = (i + j) % 4;
  // Exact match: const hue = (colorIndex * 60 + t * 30) % 360;
  const hue = (colorIndex * 60 + t * 30) % 360;
  // Exact match: const brightness = 60 + noiseVal * 35;
  const brightness = 60 + n * 35;
  return { h: hue, s: 75, b: brightness, a: 70 };
}

/**
 * Palette-based coloring (from config palette)
 */
function paletteColor(p5, i, j, t, n, palette) {
  if (!palette || palette.length === 0) {
    return { h: 0, s: 100, b: 100, a: 100 }; // Bright red as fallback
  }
  
  const index = Math.floor(n * palette.length) % palette.length;
  const hex = palette[index];
  
  // Convert hex to HSB - temporarily switch to RGB to parse hex, then get HSB
  try {
    // Save current color mode
    const currentMode = p5._colorMode || 'HSB';
    
    // Temporarily switch to RGB to parse hex
    p5.colorMode(p5.RGB, 255, 255, 255, 255);
    const c = p5.color(hex);
    const r = p5.red(c);
    const g = p5.green(c);
    const b = p5.blue(c);
    
    // Switch back to HSB
    p5.colorMode(p5.HSB, 360, 100, 100, 100);
    
    // Convert RGB to HSB manually
    const max = Math.max(r, g, b) / 255;
    const min = Math.min(r, g, b) / 255;
    const delta = max - min;
    
    let h = 0;
    if (delta !== 0) {
      if (max === r / 255) {
        h = 60 * (((g - b) / 255) / delta);
      } else if (max === g / 255) {
        h = 60 * (2 + ((b - r) / 255) / delta);
      } else {
        h = 60 * (4 + ((r - g) / 255) / delta);
      }
      if (h < 0) h += 360;
    }
    
    const s = max === 0 ? 0 : (delta / max) * 100;
    const brightness = max * 100;
    
    return {
      h: h,
      s: s,
      b: brightness,
      a: 100, // Full opacity
    };
  } catch (e) {
    console.error('Error converting hex to HSB:', hex, e);
    // Return bright red as fallback so we can see if rendering works
    return { h: 0, s: 100, b: 100, a: 100 };
  }
}

/**
 * Gradient coloring (based on position)
 */
function gradientColor(p5, i, j, maxI, maxJ, palette) {
  const ratioX = i / maxI;
  const ratioY = j / maxJ;
  const ratio = (ratioX + ratioY) / 2;

  const index1 = Math.floor(ratio * (palette.length - 1));
  const index2 = Math.min(index1 + 1, palette.length - 1);
  const blend = (ratio * (palette.length - 1)) % 1;

  try {
    const c1 = p5.color(palette[index1]);
    const c2 = p5.color(palette[index2]);
    const c = p5.lerpColor(c1, c2, blend);
    return {
      h: p5.hue(c),
      s: p5.saturation(c),
      b: p5.brightness(c),
      a: 70,
    };
  } catch (e) {
    return { h: 180, s: 50, b: 50, a: 70 };
  }
}

/**
 * Noise-based color variation
 */
function noiseColor(p5, i, j, t, noiseScale = 0.1, palette) {
  const n = p5.noise(i * noiseScale, j * noiseScale, t);
  const index = Math.floor(n * palette.length) % palette.length;
  try {
    const c = p5.color(palette[index]);
    return {
      h: (p5.hue(c) + t * 2) % 360,
      s: p5.saturation(c),
      b: p5.brightness(c),
      a: 70,
    };
  } catch (e) {
    return { h: 180, s: 50, b: 50, a: 70 };
  }
}

/**
 * Index-based color (cycled through palette)
 */
function indexColor(p5, i, j, palette) {
  const index = (i + j) % palette.length;
  try {
    const c = p5.color(palette[index]);
    return {
      h: p5.hue(c),
      s: p5.saturation(c),
      b: p5.brightness(c),
      a: 70,
    };
  } catch (e) {
    return { h: 180, s: 50, b: 50, a: 70 };
  }
}




/**
 * Rendering Modules
 * Draw shapes/elements
 */

/**
 * Render circle
 */
function renderCircle(p5, x, y, size) {
  p5.ellipse(x, y, size, size);
}

/**
 * Render rectangle
 */
function renderRect(p5, x, y, size) {
  p5.rectMode(p5.CENTER);
  p5.rect(x, y, size, size);
}

/**
 * Render triangle
 */
function renderTriangle(p5, x, y, size) {
  p5.triangle(
    x,
    y - size / 2,
    x - size / 2,
    y + size / 2,
    x + size / 2,
    y + size / 2
  );
}

/**
 * Render line
 */
function renderLine(p5, x, y, size, angle = 0) {
  p5.push();
  p5.translate(x, y);
  p5.rotate(angle);
  p5.line(-size / 2, 0, size / 2, 0);
  p5.pop();
}

/**
 * Render cross
 */
function renderCross(p5, x, y, size) {
  const halfSize = size / 2;
  p5.line(x - halfSize, y, x + halfSize, y);
  p5.line(x, y - halfSize, x, y + halfSize);
}

/**
 * Render flow curve (multi-segment line)
 */
function renderFlowCurve(p5, x, y, size, shape, context) {
  const cfg = context.config || {};
  const steps = cfg.steps || 15;
  const noiseScale = cfg.noiseScale || 0.01;
  
  // Use size as the horizontal span
  const stepSize = size / steps;
  
  p5.beginShape();
  p5.noFill(); // Ensure curves aren't filled by default
  
  for (let s = 0; s < steps; s++) {
    const sx = x + s * stepSize;
    
    // Use x/y as noise seeds if 'i' is not available, or combine them
    // To replicate flowField 'i' dependency, we can try to use x/y coordinates
    const nx = x * 0.01;
    const ny = y * 0.01;
    
    const noiseVal = p5.noise(nx, ny + s * noiseScale, context.t);
    
    // Vertical displacement based on noise
    const sy = y + noiseVal * size - size/2;
    p5.vertex(sx, sy);
  }
  p5.endShape();
}

/**
 * Shape switcher (renders based on shape name)
 */
function renderShape(p5, x, y, size, shape = "circle", context) {
  switch (shape?.toLowerCase()) {
    case "circle":
      renderCircle(p5, x, y, size);
      break;
    case "rect":
    case "rectangle":
    case "square":
      renderRect(p5, x, y, size);
      break;
    case "triangle":
      renderTriangle(p5, x, y, size);
      break;
    case "line":
      renderLine(p5, x, y, size);
      break;
    case "cross":
      renderCross(p5, x, y, size);
      break;
    default:
      renderCircle(p5, x, y, size); // Default to circle
  }
}




/**
 * Transform Modules
 * Apply transformations/jitter/offset to positions
 */

/**
 * No transformation (as-is)
 */
function noTransform(p5, x, y) {
  return { x, y };
}

/**
 * Random jitter
 */
function jitterTransform(p5, x, y, jitterAmount = 0.25, cellSize = 100) {
  const jx = (p5.random() - 0.5) * jitterAmount * cellSize * 0.2;
  const jy = (p5.random() - 0.5) * jitterAmount * cellSize * 0.2;
  return { x: x + jx, y: y + jy };
}

/**
 * Noise-based offset
 */
function noiseOffsetTransform(p5, x, y, i, j, t, noiseScale = 0.1, offsetAmount = 20) {
  const offsetX = (p5.noise(i * noiseScale, j * noiseScale, t) - 0.5) * offsetAmount;
  const offsetY = (p5.noise(i * noiseScale + 100, j * noiseScale + 100, t) - 0.5) * offsetAmount;
  return { x: x + offsetX, y: y + offsetY };
}

/**
 * Circular orbit transform
 */
function orbitTransform(p5, x, y, centerX, centerY, t, orbitSpeed = 0.01, radius = 10) {
  const angle = t * orbitSpeed;
  const offsetX = Math.cos(angle) * radius;
  const offsetY = Math.sin(angle) * radius;
  return { x: x + offsetX, y: y + offsetY };
}





function defaultSetup(p5, config) {
  p5.colorMode(p5.HSB, 360, 100, 100, 100);
  // Use HSB background like original sketches: (0, 0, 12) = dark gray
  p5.background(0, 0, 12);
  p5.noStroke();
}

function invertedSetup(p5, config) {
  p5.colorMode(p5.RGB, 255, 255, 255, 255);
  p5.background(240, 240, 240);
  p5.stroke(0);
  p5.strokeWeight(1);
  p5.noFill();
}

/**
 * RGB setup for templates that use RGB color mode (like ballots)
 */
function rgbSetup(p5, config) {
  p5.colorMode(p5.RGB, 255, 255, 255, 255);
  p5.noStroke();
}





function transparentFade(p5, config) {
  // Assumes HSB mode from default setup, or works reasonably in RGB
  p5.background(
    0,
    0,
    12,
    Math.min(100, Math.max(0, config.fade ? config.fade * 100 : 8))
  );
}

function solidBackground(p5, config) {
  // Use config.background if provided (hex string works in any color mode)
  if (config.background) {
    p5.background(config.background);
  } else {
    // Fallback: try to detect color mode and use appropriate default
    // For RGB mode (ballots), use light gray
    // For HSB mode (gridPattern), use dark gray
    // Since we can't reliably detect mode, default to HSB dark gray for backward compatibility
    // Templates using RGB should always provide config.background
    p5.background(0, 0, 12); // Dark gray in HSB mode
  }
}

function noBackground(p5, config) {
  // Use config.background if provided, otherwise no background (transparent/black)
  // For ballots (RGB mode), we should still set a background if config.background is provided
  if (config.background && config.background !== "none") {
    p5.background(config.background);
  }
  // Otherwise, don't set background (will be black/transparent)
}

function trailFade(p5, config) {
  p5.push();
  p5.noStroke();
  // Default to black with low alpha if not specified
  // We can't easily parse hex to RGB/HSB without helper, so we rely on p5's color parsing if available
  // or just use simple HSB/RGB values
  
  // Try to respect the color mode or config
  if (config.background && config.background.startsWith('#')) {
      // If it's a hex, we can try to use it with alpha but p5 doesn't support hex+alpha easily in all versions
      // So we'll just use black with alpha for trails usually
      p5.fill(0, 8); 
  } else {
      // Assume HSB or RGB, use 0,0,0 (black)
      p5.fill(0, 0, 0, 8);
  }
  
  p5.rect(0, 0, p5.width, p5.height);
  p5.pop();
}




function gridTraversal(p5, config, context, drawElementFn) {
  const { gridSize } = context;
  for (let i = 0; i < gridSize; i++) {
    for (let j = 0; j < gridSize; j++) {
      drawElementFn(i, j);
    }
  }
}

function randomTraversal(p5, config, context, drawElementFn) {
  const { gridSize } = context;
  // Use gridSize squared to maintain similar density
  const count = gridSize * gridSize;
  
  for (let k = 0; k < count; k++) {
    // Random float positions within grid range
    const i = p5.random(gridSize);
    const j = p5.random(gridSize);
    drawElementFn(i, j);
  }
}

function columnTraversal(p5, config, context, drawElementFn) {
    const { gridSize } = context;
    // Iterate down columns
    for (let i = 0; i < gridSize; i++) {
        // Draw a continuous line or more dense points in column?
        // For now just same as grid but strictly column order (no visual diff unless effect depends on order)
        for (let j = 0; j < gridSize; j++) {
            drawElementFn(i, j);
        }
    }
}

function densityTraversal(p5, config, context, drawElementFn) {
  const count = Math.max(5, Math.floor(config.density || 80));
  // We only need a single index, passing 0 as j
  for (let i = 0; i < count; i++) {
    drawElementFn(i, 0);
  }
}




function timeBasedContext(p5, config) {
  const t = p5.frameCount * (config.speed || 0.012);
  const gridSize = config.gridSize || Math.floor(Math.sqrt(60));
  const cellSize = Math.min(p5.width, p5.height) / gridSize;
  return { t, gridSize, cellSize, config };
}

function mouseBasedContext(p5, config) {
  // Map mouseX to time, normalized
  const t = (p5.mouseX / p5.width) * 10;
  const gridSize = config.gridSize || Math.floor(Math.sqrt(60));
  const cellSize = Math.min(p5.width, p5.height) / gridSize;
  return { t, gridSize, cellSize, config };
}


/**
 * Modular Template System
 * Each module is a plug-and-play function that can be swapped to create variations
 */

// Position Modules

// Size Modules  

// Color Modules

// Render Modules

// Transform Modules

// Setup Modules

// Background Modules

// Traversal Modules

// Context Modules





/**
 * Universal Modular Runtime
 * 
 * This runtime interprets a JSON configuration to compose an artwork
 * from atomic modules.
 * 
 * @param {Object} config The configuration object
 * @returns {Object} A p5.js sketch object { setup, draw }
 */
function generatedSketchFromConfig(config) {
  // Default configuration
  const cfg = {
    seed: 12345,
    width: 1024,
    height: 1024,
    gridSize: 20,
    speed: 0.01,
    shape: 'circle',
    palette: ['#000000', '#ffffff'],
    background: '#ffffff',
    modules: {
      positioning: 'grid',
      sizing: 'constant',
      coloring: 'palette',
      transform: 'none',
      rendering: 'shape'
    },
    ...config
  };

  // Module Maps - mapping string keys to functions
  const positioningModules = {
    grid: gridPosition,
    offsetGrid: offsetGridPosition,
    spiral: spiralPosition,
    flowGrid: flowGridPosition,
    random: randomPosition
  };

  const sizingModules = {
    noise: noiseSize,
    constant: constantSize,
    distance: distanceSize,
    pulse: pulseSize
  };

  const coloringModules = {
    time: timeBasedColor,
    palette: paletteColor,
    gradient: gradientColor,
    noise: noiseColor,
    index: indexColor
  };

  const transformModules = {
    none: noTransform,
    jitter: jitterTransform,
    noiseOffset: noiseOffsetTransform,
    orbit: orbitTransform
  };

  const renderingModules = {
    circle: renderCircle,
    rect: renderRect,
    triangle: renderTriangle,
    shape: renderShape
  };

  return {
    setup: (p5) => {
      p5.randomSeed(cfg.seed);
      p5.noiseSeed(cfg.seed);
      
      p5.createCanvas(cfg.width, cfg.height);
      
      // Set color mode to HSB FIRST (before any color operations)
      p5.colorMode(p5.HSB, 360, 100, 100, 100);
      
      // Set background - convert hex to HSB values
      if (cfg.background) {
        try {
          const bgColor = p5.color(cfg.background);
          p5.background(p5.hue(bgColor), p5.saturation(bgColor), p5.brightness(bgColor));
        } catch (e) {
          // Fallback: white background in HSB
          p5.background(0, 0, 100);
        }
      } else {
        p5.background(0, 0, 12); // Default dark gray in HSB
      }
      
      p5.noStroke();
      
      // Don't call noLoop here - let the caller control animation
    },

    draw: (p5) => {
      // Clear background each frame (unless tracing)
      if (!cfg.trace) {
        if (cfg.background) {
          try {
            const bgColor = p5.color(cfg.background);
            p5.background(p5.hue(bgColor), p5.saturation(bgColor), p5.brightness(bgColor));
          } catch (e) {
            p5.background(0, 0, 100); // White fallback
          }
        } else {
          p5.background(0, 0, 12);
        }
      }

      const t = p5.frameCount * cfg.speed;
      const g = Math.floor(cfg.gridSize);
      const cell = p5.width / g;
      
      // Debug: ensure we have valid grid
      if (g <= 0 || cell <= 0) {
        console.warn('Invalid grid size:', g, cell);
        return;
      }

      // Get selected modules
      const getPos = positioningModules[cfg.modules.positioning] || positioningModules.grid;
      const getSize = sizingModules[cfg.modules.sizing] || sizingModules.constant;
      const getColor = coloringModules[cfg.modules.coloring] || coloringModules.palette;
      const getTransform = transformModules[cfg.modules.transform] || transformModules.none;
      // Rendering module is usually handled by renderShape, but could be direct
      const render = renderShape; 

      // Context object for modules that need it
      const context = {
        config: cfg,
        gridSize: g,
        t: t
      };
      
      // Universal Loop - grid-based iteration
      for (let i = 0; i < g; i++) {
        for (let j = 0; j < g; j++) {
          
          // 1. Position
          // Different positioning modules have different signatures
          let pos;
          if (cfg.modules.positioning === 'spiral') {
            const index = i * g + j;
            const total = g * g;
            pos = getPos(i, j, cell, p5, context);
          } else if (cfg.modules.positioning === 'flowGrid' || cfg.modules.positioning === 'random') {
            pos = getPos(i, j, cell, p5, context);
          } else {
            pos = getPos(i, j, cell);
          }

          if (!pos || pos.x === undefined || pos.y === undefined) continue;

          // 2. Size
          let size;
          if (cfg.modules.sizing === 'distance') {
            size = getSize(p5, i, j, g, g, cell);
          } else {
            size = getSize(p5, i, j, t, cell);
          }
          
          // Ensure size is valid
          if (!size || size <= 0 || isNaN(size)) {
            size = cell * 0.5; // Default size
          }

          // 3. Color
          // Normalized noise value often needed for color
          const n = p5.noise(i * 0.1, j * 0.1, t); 
          const color = getColor(p5, i, j, t, n, cfg.palette);
          
          if (color && color.h !== undefined) {
            p5.fill(color.h, color.s, color.b, color.a || 100);
            p5.noStroke(); // or configurable stroke
          } else {
            // Fallback color if color function fails
            p5.fill(180, 50, 50, 100);
            p5.noStroke();
          }

          // 4. Transform
          // Apply additional transforms (jitter, orbit, etc.)
          let finalPos;
          if (cfg.modules.transform === 'orbit') {
            finalPos = getTransform(p5, pos.x, pos.y, p5.width/2, p5.height/2, t, 0.01, 10);
          } else {
            finalPos = getTransform(p5, pos.x, pos.y, i, j, t, 0.25, cell);
          }

          // 5. Render
          // Ensure we have valid position and size before rendering
          if (finalPos && finalPos.x !== undefined && finalPos.y !== undefined && size > 0 && !isNaN(finalPos.x) && !isNaN(finalPos.y) && !isNaN(size)) {
            try {
              // Ensure fill is set before rendering
              if (!p5._renderer._doFill) {
                // Force fill if not set
                p5.fill(180, 50, 50, 100); // Default cyan
              }
              render(p5, finalPos.x, finalPos.y, size, cfg.shape, context);
            } catch (e) {
              // Fallback: draw a simple circle if render fails
              console.error('Render error:', e);
              p5.fill(180, 50, 50, 100); // Force fill
              p5.ellipse(finalPos.x, finalPos.y, size, size);
            }
          }
        }
      }
    }
  };
}


  
  // Make it globally available
  window.generatedSketchFromConfig = generatedSketchFromConfig;
})();
