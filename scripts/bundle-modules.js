#!/usr/bin/env node

/**
 * Bundle Modules Script
 * Bundles UniversalModularRuntime.js and all its module dependencies
 * into a single file for use in the web viewer
 */

const fs = require('fs');
const path = require('path');

const TEMPLATES_DIR = path.join(__dirname, '../src/templates');
const OUTPUT_DIR = path.join(__dirname, '../dist');
const RUNTIME_FILE = path.join(TEMPLATES_DIR, 'UniversalModularRuntime.js');

/**
 * Inline ES module imports by reading and embedding module files
 * @param {string} code - Template code with imports
 * @param {string} templatePath - Path to the template file
 * @returns {string} Code with imports inlined
 */
function inlineModuleImports(code, templatePath) {
  const templateDir = path.dirname(templatePath);
  const processedFiles = new Set();
  const moduleExports = {};

  // Find all import statements (including export * from)
  const importRegex = /(?:import|export)\s+(?:\*\s+from\s+)?(?:[^'"]*from\s+)?['"](.+?)['"];?/gs;
  let match;
  const imports = [];
  const importStatements = [];

  // Collect all import statements
  while ((match = importRegex.exec(code)) !== null) {
    const importPath = match[1];
    if (importPath && (importPath.startsWith('./modules/') || importPath.startsWith('./'))) {
      // Handle both './modules/index.js' and './modules/positioning.js'
      let modulePath = importPath;
      if (!modulePath.endsWith('.js')) {
        modulePath = modulePath + '.js';
      }
      
      // Resolve path relative to templateDir
      let fullPath;
      if (path.isAbsolute(modulePath)) {
        fullPath = modulePath;
      } else {
        fullPath = path.join(templateDir, modulePath);
      }
      
      if (fs.existsSync(fullPath)) {
        if (!imports.find((imp) => imp.fullPath === fullPath)) {
          imports.push({
            statement: match[0],
            path: importPath,
            fullPath: fullPath,
          });
        }
        importStatements.push(match[0]);
      } else {
        console.warn(`‚ö†Ô∏è  Module file not found: ${fullPath}`);
      }
    }
  }

  // Read and inline each module file (only once per file)
  imports.forEach((imp) => {
    if (!processedFiles.has(imp.fullPath)) {
      processedFiles.add(imp.fullPath);
      let moduleCode = fs.readFileSync(imp.fullPath, 'utf8');
      
      // Recursively inline imports in module files
      moduleCode = inlineModuleImports(moduleCode, imp.fullPath);
      
      // Remove export keywords and convert to regular functions/constants
      moduleCode = moduleCode.replace(/export\s+function\s+(\w+)/g, 'function $1');
      moduleCode = moduleCode.replace(/export\s+const\s+(\w+)/g, 'const $1');
      moduleCode = moduleCode.replace(/export\s+default\s+/g, '');
      // Handle export * from statements (they should be handled by recursive inlining)
      moduleCode = moduleCode.replace(/export\s+\*\s+from\s+['"].+?['"];?/g, '');
      moduleCode = moduleCode.replace(/export\s*\{([^}]+)\}/g, (match, exports) => {
        // Handle named exports like export { func1, func2 }
        return exports.split(',').map(e => e.trim()).join('\n');
      });

      // Store the module code
      const moduleName = path.basename(imp.fullPath, '.js');
      moduleExports[moduleName] = moduleCode;
    }
  });

  // Remove all import statements from the code
  let inlinedCode = code;
  importStatements.forEach((stmt) => {
    const escaped = stmt.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    inlinedCode = inlinedCode.replace(new RegExp(escaped, 'gs'), '');
  });

  // Prepend all module code before the main template code
  const allModulesCode = Object.values(moduleExports).join('\n\n');
  const result = allModulesCode + '\n\n' + inlinedCode;

  return result;
}

/**
 * Bundle the runtime and modules into a single file
 */
function bundleRuntime() {
  console.log('üì¶ Bundling UniversalModularRuntime...');

  // Ensure output directory exists
  if (!fs.existsSync(OUTPUT_DIR)) {
    fs.mkdirSync(OUTPUT_DIR, { recursive: true });
  }

  // Read the runtime file
  if (!fs.existsSync(RUNTIME_FILE)) {
    console.error(`‚ùå Runtime file not found: ${RUNTIME_FILE}`);
    process.exit(1);
  }

  let runtimeCode = fs.readFileSync(RUNTIME_FILE, 'utf8');

  // Inline all module imports
  runtimeCode = inlineModuleImports(runtimeCode, RUNTIME_FILE);

  // Remove ES module export and convert to function that can be called
  runtimeCode = runtimeCode.replace(
    /export\s+default\s+function\s+(\w+)/,
    'function $1'
  );

  // Wrap in IIFE to avoid global scope pollution
  const bundledCode = `/**
 * Universal Modular Runtime (Bundled)
 * This file is auto-generated by scripts/bundle-modules.js
 * Do not edit directly - edit src/templates/UniversalModularRuntime.js instead
 */

(function() {
${runtimeCode}
  
  // Make it globally available
  window.generatedSketchFromConfig = generatedSketchFromConfig;
})();
`;

  // Write bundled file
  const outputPath = path.join(OUTPUT_DIR, 'modular-runtime.js');
  fs.writeFileSync(outputPath, bundledCode, 'utf8');

  console.log(`‚úÖ Bundled runtime written to: ${outputPath}`);
  console.log(`   Size: ${(bundledCode.length / 1024).toFixed(2)} KB`);
}

// Run bundling
bundleRuntime();

